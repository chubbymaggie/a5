
pluginName = "NotCompatible data decyptor"

enable = True

type = "known"

import logging
logger = logging.getLogger(__name__)


class PluginClass:
    msg = "autocreated NotCompatible data decryptor"

    def get_dns_rule(self,domain):
      return 'alert udp any any -> any 53 (msg:"%s"; content:"%s"; nocase;)' % (self.msg,domain)

    def get_notc_rule(self,port):
      return 'alert tcp any any -> any %s (msg:"%s"; flow:established, to_server; dsize:13; content:"|04|"; depth:1; content:"|01 05 00 00 00 00 07 00|";)' % (port,self.msg)
       


    def run(self,pcap,apk):
        ruleList = list()
        commentList = list()

	if pcap is None or apk is None:
          commentList.append("this plugin requires a pcap file and an apk to work")
          logger.error("plugin requires a pcap and an apk...but didn't get em")
          return (pluginName,None,commentList)


        try:
          from scapy.all import PcapReader,hexdump,ls
          import sys

          my_reader = PcapReader(pcap)
          if(self.findNotCompatiblePhoneHome(my_reader)):
            pt = self.decryptNotCompatibleData(apk,ruleList,commentList)
            (primary,secondary,pport,sport) = pt.split('|')
            commentList.append("new notcompatible sockets: %s:%s , %s:%s" % (primary,pport,secondary,sport))
            ruleList.append(self.get_dns_rule(primary))
            ruleList.append(self.get_dns_rule(secondary))
            ruleList.append(self.get_notc_rule(pport))
            ruleList.append(self.get_notc_rule(sport))
        except IOError:
          logger.error("Failed reading pcap")
          return (pluginName, None, None)

        return (pluginName, ruleList, commentList)

    def decrypt(self,passkey,param):
        from Crypto.Hash import SHA256
        from Crypto.Cipher import AES
        keyhash = SHA256.new(passkey)
        key = keyhash.digest()
    
        #print key.hexdigest()
    
        cipher = AES.new(str(key), AES.MODE_ECB, "ignored")
    
        buf = buffer(param,0,len(param))
        return cipher.decrypt(buf)

    def decryptNotCompatibleData(self,apk,rules,comments):
        from scapy.all import hexdump
        #0000000: 3e34 c03b 010a 6147 6bec 9c52 3c13 4319  >4.;..aGk..R<.C.
        #0000010: 012d 9d2c 2a8a 49d9 6d67 e383 06ca 8a5e  .-.,*.I.mg.....^
        #0000020: 5651 cf74 41f5 c479 0b4b e887 382e 20da  VQ.tA..y.K..8. .
    
        #notcompatibleapp.eu|3na3budet9.ru|8014|8014
   
        #raw data file 
        #filename = "/path/to/notcompatible/res/raw/data"
        #size = os.path.getsize(filename)
        #f = open(filename, 'r')
        #data = bytearray(size)
        #f.readinto(data)


        #directly from the zip (relies upon working zip imlementation in python!)
        import zipfile
        file = zipfile.ZipFile(apk,"r")
        #for name in file.namelist():
        #   print name
        data = file.read("res/raw/data")
    
        hexdump(data)
    
        key = "ZTY4MGE5YQo"
        comments.append("key: %s" % key)
        plaintext = self.decrypt(key, data)
        comments.append("decrypted: %s" % plaintext)

        return plaintext

    def findNotCompatiblePhoneHome(self,reader):
      from scapy.all import TCP,Raw,hexdump
      for pkt in reader:
        if pkt.haslayer(TCP):
          if pkt.haslayer(Raw):
            data = pkt.getlayer(Raw).load
            if len(data) == 13:
              #hexdump(data)
              if data[0] == '\x04':
                #initialcall = bytearray([0x01, 0x05, 0x00, 0x00, 0x00])
                initialcall = bytearray.fromhex("01 05 00 00 00")
                if data[3:8] == initialcall:
                  return True
      return False
    
